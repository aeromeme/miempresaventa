/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Datos para crear un nuevo producto
 */
export interface CreateProductoDto {
    /**
     * Nombre del producto
     */
    'nombre': string;
    /**
     * Precio del producto
     */
    'precio': number;
    /**
     * Cantidad inicial en stock
     */
    'stock': number;
}
/**
 * Configuración de monedas del sistema
 */
export interface MonedaConfigDto {
    /**
     * Código de la moneda por defecto
     */
    'monedaPorDefecto'?: string;
    /**
     * Lista de códigos de monedas soportadas
     */
    'monedasSoportadas'?: Array<string>;
}
/**
 * Respuesta paginada genérica que contiene datos y metadatos de paginación
 */
export interface PagedResponse {
    /**
     * Lista de elementos de la página actual
     */
    'content'?: Array<object>;
    /**
     * Número de página actual (inicia en 0)
     */
    'page'?: number;
    /**
     * Cantidad de elementos por página
     */
    'size'?: number;
    /**
     * Total de elementos en toda la colección
     */
    'totalElements'?: number;
    /**
     * Total de páginas disponibles
     */
    'totalPages'?: number;
    /**
     * Indica si es la primera página
     */
    'first'?: boolean;
    /**
     * Indica si es la última página
     */
    'last'?: boolean;
    /**
     * Indica si hay página siguiente
     */
    'hasNext'?: boolean;
    /**
     * Indica si hay página anterior
     */
    'hasPrevious'?: boolean;
    'empty'?: boolean;
    'numberOfElements'?: number;
}
export interface ProblemDetail {
    'type'?: string;
    'title'?: string;
    'status'?: number;
    'detail'?: string;
    'instance'?: string;
    'properties'?: { [key: string]: object; };
}
/**
 * Datos de un producto
 */
export interface ProductoDto {
    /**
     * Identificador único del producto
     */
    'id'?: string;
    /**
     * Nombre del producto
     */
    'nombre'?: string;
    /**
     * Precio del producto
     */
    'precio'?: number;
    /**
     * Moneda del precio
     */
    'moneda'?: string;
    /**
     * Cantidad en stock
     */
    'stock'?: number;
}
/**
 * Datos para actualizar un producto existente. La moneda no se puede cambiar.
 */
export interface UpdateProductoDto {
    /**
     * Nuevo nombre del producto
     */
    'nombre'?: string;
    /**
     * Nuevo precio del producto
     */
    'precio'?: number;
    /**
     * Nueva cantidad en stock
     */
    'stock'?: number;
}

/**
 * ClientesApi - axios parameter creator
 */
export const ClientesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientes: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clientes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [nombre] Texto a buscar en el nombre del cliente
         * @param {string} [correo] Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesFiltrados: async (nombre?: string, correo?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clientes/buscar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }

            if (correo !== undefined) {
                localVarQueryParameter['correo'] = correo;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorCorreo: async (correo: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'correo' is not null or undefined
            assertParamExists('obtenerClientesPorCorreo', 'correo', correo)
            const localVarPath = `/api/v1/clientes/buscar-por-correo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (correo !== undefined) {
                localVarQueryParameter['correo'] = correo;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorNombre: async (nombre: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nombre' is not null or undefined
            assertParamExists('obtenerClientesPorNombre', 'nombre', nombre)
            const localVarPath = `/api/v1/clientes/buscar-por-nombre`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientesApi - functional programming interface
 */
export const ClientesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientesApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientes(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [nombre] Texto a buscar en el nombre del cliente
         * @param {string} [correo] Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesFiltrados(nombre?: string, correo?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesFiltrados(nombre, correo, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesFiltrados']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesPorCorreo(correo, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesPorCorreo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesPorNombre(nombre, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesPorNombre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientesApi - factory interface
 */
export const ClientesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientesApiFp(configuration)
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientes(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [nombre] Texto a buscar en el nombre del cliente
         * @param {string} [correo] Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesFiltrados(nombre?: string, correo?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesFiltrados(nombre, correo, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesPorCorreo(correo, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesPorNombre(nombre, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientesApi - object-oriented interface
 */
export class ClientesApi extends BaseAPI {
    /**
     * Obtiene una lista paginada de todos los clientes registrados en el sistema
     * @summary Obtener clientes paginados
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientes(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
     * @summary Buscar clientes con filtros combinados
     * @param {string} [nombre] Texto a buscar en el nombre del cliente
     * @param {string} [correo] Texto a buscar en el correo electrónico
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesFiltrados(nombre?: string, correo?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesFiltrados(nombre, correo, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
     * @summary Buscar clientes por correo electrónico
     * @param {string} correo Texto a buscar en el correo electrónico
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesPorCorreo(correo, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
     * @summary Buscar clientes por nombre
     * @param {string} nombre Texto a buscar en el nombre del cliente
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesPorNombre(nombre, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductosApi - axios parameter creator
 */
export const ProductosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizar: async (id: string, updateProductoDto: UpdateProductoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actualizar', 'id', id)
            // verify required parameter 'updateProductoDto' is not null or undefined
            assertParamExists('actualizar', 'updateProductoDto', updateProductoDto)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarPorNombre: async (nombre: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nombre' is not null or undefined
            assertParamExists('buscarPorNombre', 'nombre', nombre)
            const localVarPath = `/api/productos/buscar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crear: async (createProductoDto: CreateProductoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductoDto' is not null or undefined
            assertParamExists('crear', 'createProductoDto', createProductoDto)
            const localVarPath = `/api/productos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eliminar: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eliminar', 'id', id)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarTodos: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/productos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerConfiguracionMonedas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/productos/config/monedas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerPorId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obtenerPorId', 'id', id)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductosApi - functional programming interface
 */
export const ProductosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductosApiAxiosParamCreator(configuration)
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actualizar(id, updateProductoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.actualizar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductoDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buscarPorNombre(nombre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.buscarPorNombre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crear(createProductoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.crear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eliminar(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eliminar(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.eliminar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listarTodos(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductoDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listarTodos(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.listarTodos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonedaConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerConfiguracionMonedas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.obtenerConfiguracionMonedas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerPorId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerPorId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.obtenerPorId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductosApi - factory interface
 */
export const ProductosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductosApiFp(configuration)
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.actualizar(id, updateProductoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductoDto>> {
            return localVarFp.buscarPorNombre(nombre, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.crear(createProductoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eliminar(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.eliminar(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarTodos(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductoDto>> {
            return localVarFp.listarTodos(options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig): AxiosPromise<MonedaConfigDto> {
            return localVarFp.obtenerConfiguracionMonedas(options).then((request) => request(axios, basePath));
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerPorId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.obtenerPorId(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductosApi - object-oriented interface
 */
export class ProductosApi extends BaseAPI {
    /**
     * Actualiza un producto existente
     * @summary Actualizar producto
     * @param {string} id ID único del producto
     * @param {UpdateProductoDto} updateProductoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).actualizar(id, updateProductoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Busca productos que contengan el texto especificado en el nombre
     * @summary Buscar productos por nombre
     * @param {string} nombre Texto a buscar en el nombre del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).buscarPorNombre(nombre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un nuevo producto en el sistema
     * @summary Crear nuevo producto
     * @param {CreateProductoDto} createProductoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).crear(createProductoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un producto del sistema
     * @summary Eliminar producto
     * @param {string} id ID único del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public eliminar(id: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).eliminar(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista de todos los productos disponibles
     * @summary Listar todos los productos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listarTodos(options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).listarTodos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene la moneda por defecto y las monedas soportadas
     * @summary Obtener configuración de monedas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).obtenerConfiguracionMonedas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Busca y retorna un producto específico por su identificador único
     * @summary Obtener producto por ID
     * @param {string} id ID único del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerPorId(id: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).obtenerPorId(id, options).then((request) => request(this.axios, this.basePath));
    }
}



