/* tslint:disable */
/* eslint-disable */
/**
 * API de Ventas
 * API para gestión de ventas
 *
 * The version of the OpenAPI document: 1.0
 * Contact: soporte@miempresa.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AuthenticationRequest {
    'email': string;
    'password': string;
}
export interface AuthenticationResponse {
    'token'?: string;
}
/**
 * Datos de un cliente
 */
export interface ClienteDto {
    /**
     * Identificador único del cliente
     */
    'clienteId'?: string;
    /**
     * Nombre completo del cliente
     */
    'nombre'?: string;
    /**
     * Correo electrónico del cliente
     */
    'correo'?: string;
}
export interface ClienteIngresosDTO {
    'id'?: string;
    'nombre'?: string;
    'correo'?: string;
    'totalVentas'?: number;
    'totalIngresos'?: number;
}
/**
 * Datos para crear una línea de venta
 */
export interface CreateLineaVentaDTO {
    /**
     * ID del producto
     */
    'productoId': string;
    /**
     * Cantidad de productos
     */
    'cantidad': number;
    /**
     * Precio unitario del producto
     */
    'precioUnitario': number;
}
/**
 * Datos para crear un nuevo producto
 */
export interface CreateProductoDto {
    /**
     * Nombre del producto
     */
    'nombre': string;
    /**
     * Precio del producto
     */
    'precio': number;
    /**
     * Cantidad inicial en stock
     */
    'stock': number;
}
/**
 * Datos para crear una nueva venta
 */
export interface CreateVentaDTO {
    /**
     * ID del cliente
     */
    'clienteId': string;
    /**
     * Lista de líneas de venta
     */
    'lineasVenta': Array<CreateLineaVentaDTO>;
}
export interface IngresosMensualesDTO {
    'periodo'?: string;
    'anio'?: number;
    'mes'?: number;
    'totalVentas'?: number;
    'totalClientes'?: number;
    'ingresoTotal'?: number;
}
export interface LineaVentaDTO {
    'productoId'?: string;
    'cantidad'?: number;
    'precioUnitario'?: number;
    'subtotal'?: number;
}
/**
 * Configuración de monedas del sistema
 */
export interface MonedaConfigDto {
    /**
     * Código de la moneda por defecto
     */
    'monedaPorDefecto'?: string;
    /**
     * Lista de códigos de monedas soportadas
     */
    'monedasSoportadas'?: Array<string>;
}
/**
 * Respuesta paginada genérica que contiene datos y metadatos de paginación
 */
export interface PagedResponse {
    /**
     * Lista de elementos de la página actual
     */
    'content'?: Array<object>;
    /**
     * Número de página actual (inicia en 0)
     */
    'page'?: number;
    /**
     * Cantidad de elementos por página
     */
    'size'?: number;
    /**
     * Total de elementos en toda la colección
     */
    'totalElements'?: number;
    /**
     * Total de páginas disponibles
     */
    'totalPages'?: number;
    /**
     * Indica si es la primera página
     */
    'first'?: boolean;
    /**
     * Indica si es la última página
     */
    'last'?: boolean;
    /**
     * Indica si hay página siguiente
     */
    'hasNext'?: boolean;
    /**
     * Indica si hay página anterior
     */
    'hasPrevious'?: boolean;
    'numberOfElements'?: number;
    'empty'?: boolean;
}
export interface ProblemDetail {
    'type'?: string;
    'title'?: string;
    'status'?: number;
    'detail'?: string;
    'instance'?: string;
    'properties'?: { [key: string]: object; };
}
/**
 * Datos de un producto
 */
export interface ProductoDto {
    /**
     * Identificador único del producto
     */
    'id'?: string;
    /**
     * Nombre del producto
     */
    'nombre'?: string;
    /**
     * Precio del producto
     */
    'precio'?: number;
    /**
     * Moneda del precio
     */
    'moneda'?: string;
    /**
     * Cantidad en stock
     */
    'stock'?: number;
}
export interface TopProductoDTO {
    'id'?: string;
    'nombre'?: string;
    'totalVendido'?: number;
    'totalIngresos'?: number;
}
/**
 * Datos para actualizar una línea de venta
 */
export interface UpdateLineaVentaDTO {
    /**
     * ID del producto
     */
    'productoId': string;
    /**
     * Cantidad de productos
     */
    'cantidad': number;
    /**
     * Precio unitario del producto
     */
    'precioUnitario': number;
}
/**
 * Datos para actualizar un producto existente. La moneda no se puede cambiar.
 */
export interface UpdateProductoDto {
    /**
     * Nuevo nombre del producto
     */
    'nombre'?: string;
    /**
     * Nuevo precio del producto
     */
    'precio'?: number;
    /**
     * Nueva cantidad en stock
     */
    'stock'?: number;
}
/**
 * Datos para actualizar una venta
 */
export interface UpdateVentaDTO {
    /**
     * ID de la venta
     */
    'id': string;
    /**
     * ID del cliente
     */
    'clienteId': string;
    /**
     * Lista de líneas de venta
     */
    'lineasVenta': Array<UpdateLineaVentaDTO>;
}
export interface VentaDTO {
    'id'?: string;
    'cliente'?: ClienteDto;
    'fechaVenta'?: string;
    'total'?: number;
    'estado'?: string;
    'lineasVenta'?: Array<LineaVentaDTO>;
}

/**
 * AutenticacinApi - axios parameter creator
 */
export const AutenticacinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Autentica un usuario y retorna un token JWT
         * @summary Autenticar usuario
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticationRequest: AuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRequest' is not null or undefined
            assertParamExists('authenticate', 'authenticationRequest', authenticationRequest)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutenticacinApi - functional programming interface
 */
export const AutenticacinApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutenticacinApiAxiosParamCreator(configuration)
    return {
        /**
         * Autentica un usuario y retorna un token JWT
         * @summary Autenticar usuario
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinApi.authenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutenticacinApi - factory interface
 */
export const AutenticacinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutenticacinApiFp(configuration)
    return {
        /**
         * Autentica un usuario y retorna un token JWT
         * @summary Autenticar usuario
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(authenticationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutenticacinApi - object-oriented interface
 */
export class AutenticacinApi extends BaseAPI {
    /**
     * Autentica un usuario y retorna un token JWT
     * @summary Autenticar usuario
     * @param {AuthenticationRequest} authenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AutenticacinApiFp(this.configuration).authenticate(authenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientesApi - axios parameter creator
 */
export const ClientesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientes: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clientes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [query] Texto a buscar en el nombre o correo del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesFiltrados: async (query?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clientes/buscar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorCorreo: async (correo: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'correo' is not null or undefined
            assertParamExists('obtenerClientesPorCorreo', 'correo', correo)
            const localVarPath = `/api/clientes/buscar-por-correo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (correo !== undefined) {
                localVarQueryParameter['correo'] = correo;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorNombre: async (nombre: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nombre' is not null or undefined
            assertParamExists('obtenerClientesPorNombre', 'nombre', nombre)
            const localVarPath = `/api/clientes/buscar-por-nombre`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientesApi - functional programming interface
 */
export const ClientesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientesApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientes(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [query] Texto a buscar en el nombre o correo del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesFiltrados(query?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesFiltrados(query, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesFiltrados']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesPorCorreo(correo, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesPorCorreo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesPorNombre(nombre, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientesApi.obtenerClientesPorNombre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientesApi - factory interface
 */
export const ClientesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientesApiFp(configuration)
    return {
        /**
         * Obtiene una lista paginada de todos los clientes registrados en el sistema
         * @summary Obtener clientes paginados
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientes(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
         * @summary Buscar clientes con filtros combinados
         * @param {string} [query] Texto a buscar en el nombre o correo del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesFiltrados(query?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesFiltrados(query, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
         * @summary Buscar clientes por correo electrónico
         * @param {string} correo Texto a buscar en el correo electrónico
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesPorCorreo(correo, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
         * @summary Buscar clientes por nombre
         * @param {string} nombre Texto a buscar en el nombre del cliente
         * @param {number} [page] Número de página (inicia en 0)
         * @param {number} [size] Cantidad de elementos por página
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagedResponse> {
            return localVarFp.obtenerClientesPorNombre(nombre, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientesApi - object-oriented interface
 */
export class ClientesApi extends BaseAPI {
    /**
     * Obtiene una lista paginada de todos los clientes registrados en el sistema
     * @summary Obtener clientes paginados
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientes(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientes(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes aplicando filtros por nombre y/o correo electrónico
     * @summary Buscar clientes con filtros combinados
     * @param {string} [query] Texto a buscar en el nombre o correo del cliente
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesFiltrados(query?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesFiltrados(query, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes cuyo correo electrónico contenga el texto especificado
     * @summary Buscar clientes por correo electrónico
     * @param {string} correo Texto a buscar en el correo electrónico
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesPorCorreo(correo: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesPorCorreo(correo, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista paginada de clientes cuyo nombre contenga el texto especificado
     * @summary Buscar clientes por nombre
     * @param {string} nombre Texto a buscar en el nombre del cliente
     * @param {number} [page] Número de página (inicia en 0)
     * @param {number} [size] Cantidad de elementos por página
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesPorNombre(nombre: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ClientesApiFp(this.configuration).obtenerClientesPorNombre(nombre, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductosApi - axios parameter creator
 */
export const ProductosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizar: async (id: string, updateProductoDto: UpdateProductoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('actualizar', 'id', id)
            // verify required parameter 'updateProductoDto' is not null or undefined
            assertParamExists('actualizar', 'updateProductoDto', updateProductoDto)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarPorNombre: async (nombre: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nombre' is not null or undefined
            assertParamExists('buscarPorNombre', 'nombre', nombre)
            const localVarPath = `/api/productos/buscar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crear: async (createProductoDto: CreateProductoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductoDto' is not null or undefined
            assertParamExists('crear', 'createProductoDto', createProductoDto)
            const localVarPath = `/api/productos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eliminar: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eliminar', 'id', id)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarTodos: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/productos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerConfiguracionMonedas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/productos/config/monedas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerPorId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obtenerPorId', 'id', id)
            const localVarPath = `/api/productos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductosApi - functional programming interface
 */
export const ProductosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductosApiAxiosParamCreator(configuration)
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actualizar(id, updateProductoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.actualizar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductoDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buscarPorNombre(nombre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.buscarPorNombre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crear(createProductoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.crear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eliminar(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eliminar(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.eliminar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listarTodos(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductoDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listarTodos(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.listarTodos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonedaConfigDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerConfiguracionMonedas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.obtenerConfiguracionMonedas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerPorId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerPorId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductosApi.obtenerPorId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductosApi - factory interface
 */
export const ProductosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductosApiFp(configuration)
    return {
        /**
         * Actualiza un producto existente
         * @summary Actualizar producto
         * @param {string} id ID único del producto
         * @param {UpdateProductoDto} updateProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.actualizar(id, updateProductoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Busca productos que contengan el texto especificado en el nombre
         * @summary Buscar productos por nombre
         * @param {string} nombre Texto a buscar en el nombre del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductoDto>> {
            return localVarFp.buscarPorNombre(nombre, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateProductoDto} createProductoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.crear(createProductoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un producto del sistema
         * @summary Eliminar producto
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eliminar(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.eliminar(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista de todos los productos disponibles
         * @summary Listar todos los productos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listarTodos(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductoDto>> {
            return localVarFp.listarTodos(options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene la moneda por defecto y las monedas soportadas
         * @summary Obtener configuración de monedas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig): AxiosPromise<MonedaConfigDto> {
            return localVarFp.obtenerConfiguracionMonedas(options).then((request) => request(axios, basePath));
        },
        /**
         * Busca y retorna un producto específico por su identificador único
         * @summary Obtener producto por ID
         * @param {string} id ID único del producto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerPorId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductoDto> {
            return localVarFp.obtenerPorId(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductosApi - object-oriented interface
 */
export class ProductosApi extends BaseAPI {
    /**
     * Actualiza un producto existente
     * @summary Actualizar producto
     * @param {string} id ID único del producto
     * @param {UpdateProductoDto} updateProductoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public actualizar(id: string, updateProductoDto: UpdateProductoDto, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).actualizar(id, updateProductoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Busca productos que contengan el texto especificado en el nombre
     * @summary Buscar productos por nombre
     * @param {string} nombre Texto a buscar en el nombre del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public buscarPorNombre(nombre: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).buscarPorNombre(nombre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un nuevo producto en el sistema
     * @summary Crear nuevo producto
     * @param {CreateProductoDto} createProductoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public crear(createProductoDto: CreateProductoDto, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).crear(createProductoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un producto del sistema
     * @summary Eliminar producto
     * @param {string} id ID único del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public eliminar(id: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).eliminar(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista de todos los productos disponibles
     * @summary Listar todos los productos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listarTodos(options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).listarTodos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene la moneda por defecto y las monedas soportadas
     * @summary Obtener configuración de monedas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerConfiguracionMonedas(options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).obtenerConfiguracionMonedas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Busca y retorna un producto específico por su identificador único
     * @summary Obtener producto por ID
     * @param {string} id ID único del producto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerPorId(id: string, options?: RawAxiosRequestConfig) {
        return ProductosApiFp(this.configuration).obtenerPorId(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VentasApi - axios parameter creator
 */
export const VentasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateVentaDTO} createVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (createVentaDTO: CreateVentaDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVentaDTO' is not null or undefined
            assertParamExists('create', 'createVentaDTO', createVentaDTO)
            const localVarPath = `/api/ventas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVentaDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ventas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clienteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByClienteId: async (clienteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clienteId' is not null or undefined
            assertParamExists('getByClienteId', 'clienteId', clienteId)
            const localVarPath = `/api/ventas/cliente/{clienteId}`
                .replace(`{${"clienteId"}}`, encodeURIComponent(String(clienteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} estado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByEstado: async (estado: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'estado' is not null or undefined
            assertParamExists('getByEstado', 'estado', estado)
            const localVarPath = `/api/ventas/estado/{estado}`
                .replace(`{${"estado"}}`, encodeURIComponent(String(estado)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/api/ventas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateVentaDTO} updateVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, updateVentaDTO: UpdateVentaDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'updateVentaDTO' is not null or undefined
            assertParamExists('update', 'updateVentaDTO', updateVentaDTO)
            const localVarPath = `/api/ventas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVentaDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VentasApi - functional programming interface
 */
export const VentasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VentasApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateVentaDTO} createVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(createVentaDTO: CreateVentaDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VentaDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(createVentaDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VentaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} clienteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByClienteId(clienteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VentaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByClienteId(clienteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.getByClienteId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} estado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByEstado(estado: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VentaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByEstado(estado, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.getByEstado']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VentaDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateVentaDTO} updateVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, updateVentaDTO: UpdateVentaDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VentaDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, updateVentaDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VentasApi - factory interface
 */
export const VentasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VentasApiFp(configuration)
    return {
        /**
         * Crea un nuevo producto en el sistema
         * @summary Crear nuevo producto
         * @param {CreateVentaDTO} createVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(createVentaDTO: CreateVentaDTO, options?: RawAxiosRequestConfig): AxiosPromise<VentaDTO> {
            return localVarFp.create(createVentaDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<VentaDTO>> {
            return localVarFp.getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clienteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByClienteId(clienteId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VentaDTO>> {
            return localVarFp.getByClienteId(clienteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} estado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByEstado(estado: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<VentaDTO>> {
            return localVarFp.getByEstado(estado, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VentaDTO> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateVentaDTO} updateVentaDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, updateVentaDTO: UpdateVentaDTO, options?: RawAxiosRequestConfig): AxiosPromise<VentaDTO> {
            return localVarFp.update(id, updateVentaDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VentasApi - object-oriented interface
 */
export class VentasApi extends BaseAPI {
    /**
     * Crea un nuevo producto en el sistema
     * @summary Crear nuevo producto
     * @param {CreateVentaDTO} createVentaDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(createVentaDTO: CreateVentaDTO, options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).create(createVentaDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAll(options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} clienteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getByClienteId(clienteId: string, options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).getByClienteId(clienteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} estado 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getByEstado(estado: string, options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).getByEstado(estado, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateVentaDTO} updateVentaDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(id: string, updateVentaDTO: UpdateVentaDTO, options?: RawAxiosRequestConfig) {
        return VentasApiFp(this.configuration).update(id, updateVentaDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VentasDashboardApi - axios parameter creator
 */
export const VentasDashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesTopIngresos: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/ventas/clientes/top-ingresos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [anio] 
         * @param {number} [mes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerIngresoPorMes: async (anio?: number, mes?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/ventas/ingresos/por-mes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (anio !== undefined) {
                localVarQueryParameter['anio'] = anio;
            }

            if (mes !== undefined) {
                localVarQueryParameter['mes'] = mes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} anio 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerIngresosPorAnio: async (anio: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'anio' is not null or undefined
            assertParamExists('obtenerIngresosPorAnio', 'anio', anio)
            const localVarPath = `/api/dashboard/ventas/ingresos/por-anio/{anio}`
                .replace(`{${"anio"}}`, encodeURIComponent(String(anio)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerTopProductosVendidos: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/ventas/productos/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VentasDashboardApi - functional programming interface
 */
export const VentasDashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VentasDashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerClientesTopIngresos(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClienteIngresosDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerClientesTopIngresos(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasDashboardApi.obtenerClientesTopIngresos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [anio] 
         * @param {number} [mes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerIngresoPorMes(anio?: number, mes?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngresosMensualesDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerIngresoPorMes(anio, mes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasDashboardApi.obtenerIngresoPorMes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} anio 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerIngresosPorAnio(anio: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IngresosMensualesDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerIngresosPorAnio(anio, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasDashboardApi.obtenerIngresosPorAnio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obtenerTopProductosVendidos(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopProductoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obtenerTopProductosVendidos(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VentasDashboardApi.obtenerTopProductosVendidos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VentasDashboardApi - factory interface
 */
export const VentasDashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VentasDashboardApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerClientesTopIngresos(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClienteIngresosDTO>> {
            return localVarFp.obtenerClientesTopIngresos(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [anio] 
         * @param {number} [mes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerIngresoPorMes(anio?: number, mes?: number, options?: RawAxiosRequestConfig): AxiosPromise<IngresosMensualesDTO> {
            return localVarFp.obtenerIngresoPorMes(anio, mes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} anio 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerIngresosPorAnio(anio: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<IngresosMensualesDTO>> {
            return localVarFp.obtenerIngresosPorAnio(anio, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obtenerTopProductosVendidos(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TopProductoDTO>> {
            return localVarFp.obtenerTopProductosVendidos(limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VentasDashboardApi - object-oriented interface
 */
export class VentasDashboardApi extends BaseAPI {
    /**
     * 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerClientesTopIngresos(limit?: number, options?: RawAxiosRequestConfig) {
        return VentasDashboardApiFp(this.configuration).obtenerClientesTopIngresos(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [anio] 
     * @param {number} [mes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerIngresoPorMes(anio?: number, mes?: number, options?: RawAxiosRequestConfig) {
        return VentasDashboardApiFp(this.configuration).obtenerIngresoPorMes(anio, mes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} anio 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerIngresosPorAnio(anio: number, options?: RawAxiosRequestConfig) {
        return VentasDashboardApiFp(this.configuration).obtenerIngresosPorAnio(anio, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obtenerTopProductosVendidos(limit?: number, options?: RawAxiosRequestConfig) {
        return VentasDashboardApiFp(this.configuration).obtenerTopProductosVendidos(limit, options).then((request) => request(this.axios, this.basePath));
    }
}



